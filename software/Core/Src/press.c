/*
 * @Author: cherish 1771907097@qq.com
 * @Date: 2023-01-30 11:52:43
 * @LastEditors: cherish 1771907097@qq.com
 * @LastEditTime: 2023-02-07 11:20:44
 * @FilePath: \MDK-ARMc:\Users\86131\Desktop\BFMA\BFMA\Code\Automatic_Flap\Core\Src\press.c
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 */
#include "main.h"
#include "press.h"
#include "stdio.h"
#include "math.h"
#define PSI_to_Pa 6894.7f    //PSI转pa
#define Air_density 1.226f //空气密度   kg/立方米
float pressure_base;//用于数据初始化校准

/**********************用gpio模拟i2c总线, 适用于STM32系列CPU，仅包括I2C总线基本操作函数。***********************************/

/*
*********************************************************************************************************
*	函 数 名: PRESS_Delay
*	功能说明: I2C总线位延迟，最快400KHz
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void PRESS_Delay(void)
{
	uint8_t i;

	/*　
	 	下面的时间是通过安富莱AX-Pro逻辑分析仪测试得到的。
		CPU主频72MHz时，在内部Flash运行, MDK工程不优化
		循环次数为10时，SCL频率 = 205KHz 
		循环次数为7时，SCL频率 = 347KHz， SCL高电平时间1.5us，SCL低电平时间2.87us 
	 	循环次数为5时，SCL频率 = 421KHz， SCL高电平时间1.25us，SCL低电平时间2.375us 
        
    IAR工程编译效率高，不能设置为7
	*/
	for (i = 0; i < 10; i++);
}

/*
*********************************************************************************************************
*	函 数 名: PRESS_Start
*	功能说明: CPU发起I2C总线启动信号
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void PRESS_Start(void)
{
	/* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */
	PRESS_SDA_1();
	PRESS_Delay();
	PRESS_SCL_1();

	PRESS_Delay();
	PRESS_SDA_0();
	PRESS_Delay();
	PRESS_SCL_0();

}

/*
*********************************************************************************************************
*	函 数 名: PRESS_Stop
*	功能说明: CPU发起I2C总线停止信号
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void PRESS_Stop(void)
{
	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
	PRESS_SCL_0();
	PRESS_SDA_0();
	PRESS_Delay();
	PRESS_SCL_1();
	PRESS_SDA_1();
	PRESS_Delay();
}

/*
*********************************************************************************************************
*	函 数 名: PRESS_SendByte
*	功能说明: CPU向I2C总线设备发送8bit数据
*	形    参：_ucByte ： 等待发送的字节
*	返 回 值: 无
*********************************************************************************************************
*/
void PRESS_SendByte(uint8_t _ucByte)
{
	uint8_t i;

	/* 先发送字节的高位bit7 */
	for (i = 0; i < 8; i++)
	{		
		if (_ucByte & 0x80)//如果bit位>0，则SDA被置1
		{
			PRESS_SDA_1();
		}
		else
		{
			PRESS_SDA_0();
		}
		PRESS_Delay();
		PRESS_SCL_1();
		PRESS_Delay();	
		PRESS_SCL_0();
		if (i == 7)
		{
			 PRESS_SDA_1(); // 释放总线
		}
		_ucByte <<= 1;	/* 左移一个bit */
		PRESS_Delay();
	}
}
/*
*********************************************************************************************************
*	函 数 名: PRESS_ReadByte
*	功能说明: CPU从I2C总线设备读取8bit数据
*	形    参：无
*	返 回 值: 读到的数据
*********************************************************************************************************
*/
uint8_t PRESS_ReadByte(void)
{
	uint8_t i;
	uint8_t value;

	/* 读到第1个bit为数据的bit7 */
	value = 0;
	for (i = 0; i < 8; i++)
	{
		value <<= 1;
		PRESS_SCL_1();
		PRESS_Delay();
		if (PRESS_SDA_READ())
		{
			value++;
		}
		PRESS_SCL_0();
		PRESS_Delay();
	}
	return value;
}
/*
*********************************************************************************************************
*	函 数 名: PRESS_WaitAck
*	功能说明: CPU产生一个时钟，并读取器件的ACK应答信号
*	形    参：无
*	返 回 值: 返回0表示正确应答，1表示无器件响应
*********************************************************************************************************
*/
uint8_t PRESS_WaitAck(void)
{
	uint8_t re;

	PRESS_SDA_1();	/* CPU释放SDA总线 */
	PRESS_Delay();
	PRESS_SCL_1();	/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
	PRESS_Delay();
	if (PRESS_SDA_READ())	/* CPU读取SDA口线状态 */
	{
		re = 1;
		
	}
	else
	{
		re = 0;
	}
	PRESS_SCL_0();
	PRESS_Delay();
	return re;
}
/*
*********************************************************************************************************
*	函 数 名: i2c_Ack
*	功能说明: CPU产生一个ACK信号
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void PRESS_Ack(void)
{
	PRESS_SDA_0();	/* CPU驱动SDA = 0 */
	PRESS_Delay();
	PRESS_SCL_1();	/* CPU产生1个时钟 */
	PRESS_Delay();
	PRESS_SCL_0();
	PRESS_Delay();
	PRESS_SDA_1();	/* CPU释放SDA总线 */
}
/*
*********************************************************************************************************
*	函 数 名: i2c_NAck
*	功能说明: CPU产生1个NACK信号
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void PRESS_NAck(void)
{
	PRESS_SDA_1();	/* CPU驱动SDA = 1 */
	PRESS_Delay();
	PRESS_SCL_1();	/* CPU产生1个时钟 */
	PRESS_Delay();
	PRESS_SCL_0();
	PRESS_Delay();	
}
/*
*********************************************************************************************************
*	函 数 名: Press_GPIO_Config
*	功能说明: 配置I2C总线的GPIO，采用模拟IO的方式实现
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void Press_GPIO_Config(void)
{
	/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */
	PRESS_Stop();
}

/*********************************I2C总线基本操作函数结束***********************************************/

/**********************************以下为应用层命令帧**************************************************

********************************************************************************************************/
/*
*********************************************************************************************************
*	函 数 名: ms4525_ReadBytes
*	功能说明: 从MS4525D0差压传感器读取若干字节数据
*	形    参：_usSize : 数据长度，单位为字节
*	返 回 值: 0 表示失败，1表示成功
*********************************************************************************************************
*/

uint8_t bufptr[4]={0,0,0,0};//读取的数据缓存区

uint8_t Ms4525_ReadBytes( uint16_t _usSize)
{
	uint16_t i;
	
	/* 采用I2C随机读取指令序列，连续读取若干字节 */
	
	/* 第1步：发起I2C总线启动信号 */
	PRESS_Start();
	
	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
	PRESS_SendByte((PRESS_DEV_ADDR<<1)+ I2C_RD);	/* 此处是读指令 */
	
	/* 第3步：发送ACK */
	if (PRESS_WaitAck() != 0)
	{
		goto cmd_fail;	/* MS4525器件无应答 */
	}	
	
	/* 第4步：循环读取数据 */
	for (i = 0; i < _usSize; i++)
	{
		bufptr[i] = PRESS_ReadByte();	/* 读1个字节 */
		
		/* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
		if (i != _usSize - 1)
		{
			PRESS_Ack();	/* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
		}
		else
		{
			PRESS_NAck();	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
		}
	}
	/* 第5步：发送I2C总线停止信号 */
	PRESS_Stop();
	return 1;	/* 执行成功 */

cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
	/* 发送I2C总线停止信号 */
	PRESS_Stop();
	return 0;
}
/************************************************************
压力传感器型号：MS4525DO-DS3AI015DP
名称：差压传感器
气压量程为正负15psi，两端差分输出，A输出类型，供电电压3.3V。
采用I2C通信方式输出数字信号：4字节数据格式
S        6 5 4 3 2 1 0  R        A            15 14     13 12 11 10 9 8    A      7 6 5 4 3 2 1 0   A      10 9 8 7 6 5 4 3      A        2 1 0        x x x x x      N        S
-        -------------  -        -            -----     --------------     -      ---------------   -       ---------------     -        --------      -----------    -        -
开始信号    7位地址   命令位  等待从机应答   数据状态位  高6位压力AD值   主机应答   低8位压力AD值  主机应答  高8位温度AD值    主机应答  低3位温度AD值  5位无效位  主机无应答  停止信号

数据状态位：Bit15和Bit14 表示数据包的状态，00表示内部数据已更新完成，可以读取；10表示内部数据还未更新完，不能读取。
紧接着是14位的气压AD值，
再接着是11位的温度AD值，
最后5位无效位，没有相应的数据定义。

该芯片不用初始化，不接受指令，可直接进行数据的读取并根据关系式进行转换。

压力传感器I2C通信地址为0x28（7位地址），实际读取时，操作的地址是0x51.因为要左移1位，再补1就是0x51。
**************************************************************/
float pressure,temperature;//转换后的气压值，温度值
unsigned int Dpressure,Dtemperature;//读取的压力AD值，温度AD值
float P1=1638.3;    //      A型  P1=16383*10%   根据型号确定
float P2=14744.7;   //      A型  P2=16383*90    根据型号确定
float Pmax=1.0;    //传感器量程 +15psi         根据型号确定
float Pmin=-1.0;   //传感器量程 -15psi         根据型号确定
/************************
函数名：Press_convert
功  能：将采样的压力AD值转换为对应的大气压力值和环境温度值（此处的压力值为动压，动压=总压-静压）
形  参：无
返回值：无
***********************/
float Press_convert()
{
	Ms4525_ReadBytes(4);
	
	if((bufptr[0]&0xc0)==0x00)//读取数据包最高的2位位状态，判断数据是否已转换完成
	{
	Dpressure=((unsigned int)(((bufptr[0]&0x3f)<<8)+bufptr[1]));//将高6位压力AD值和低8位压力AD值合并


	Dtemperature=(unsigned int)(bufptr[2]*256+bufptr[3])>>5;    //将高8位温度AD值和低3位温度AD值合并

//得到压差 单位PSI 
	pressure=(((float)Dpressure)-P1)*(Pmax-Pmin)/P2+Pmin;       //将压力AD值根据公式换算为对应气压值

	temperature =((float)Dtemperature)*200/2047-50;             //将温度AD值根据公式换算为对应温度值
//	printf("%.1f\r\n",temperature);
	//printf("%.1f\r\n",pressure);
	}
	return pressure;
}
/**********************************************************************************************************
*函 数 名: double Press_airspeed(float press)
*功能说明: 动压转空速
*形    参: 压差
*返 回 值: 空速
***********************************************************************************************************/
double Press_airspeed(float press)
{
	double v;
    v=sqrt((2*press*PSI_to_Pa)/Air_density);//1pis=6895pa  空气密度为1.26kg/立方米
	return v; 
}
